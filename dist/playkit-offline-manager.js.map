{"version":3,"sources":["./offline-manager/webpack/universalModuleDefinition","./offline-manager/playkit-offline-manager.js","./offline-manager/webpack/bootstrap ade2e548e8819cc0efc1","./offline-manager/./utils/logger.js","./offline-manager/external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":[\"KalturaPlayer\",\"core\"]}","./offline-manager/./db-manager.js","./offline-manager/./index.js","./offline-manager/./offline-manager.js","./offline-manager/./shaka-offline-provider.js","./offline-manager/external {\"commonjs\":\"shaka-player\",\"commonjs2\":\"shaka-player\",\"amd\":\"shaka-player\",\"root\":[\"KalturaPlayer\",\"shaka\"]}","./offline-manager/../node_modules/idb/lib/idb.js","./offline-manager/../node_modules/js-logger/src/logger.js","./offline-manager/external {\"commonjs\":\"playkit-js-providers\",\"commonjs2\":\"playkit-js-providers\",\"amd\":\"playkit-js-providers\",\"root\":[\"KalturaPlayer\",\"providers\"]}"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_6__","__WEBPACK_EXTERNAL_MODULE_9__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","getLogger","JsLogger","getLogLevel","getLevel","setLogLevel","level","setLevel","value","LogLevel","undefined","_jsLogger","obj","newObj","key","default","DEBUG","INFO","TIME","WARN","ERROR","OFF","useDefaults","defaultLevel","_interopRequireDefault","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","protoProps","staticProps","_idb","_idb2","_logger","_logger2","_playkitJs","DB_NAME","DBManager","config","debug","window","open","store","dbPromise","upgradeDb","objectStoreNames","contains","createObjectStore","keyPath","storeName","item","_this","then","db","tx","transaction","objectStore","_addConfigToItem","put","complete","catch","error","Promise","reject","Error","Severity","RECOVERABLE","Category","STORAGE","Code","CANNOT_ADD_ITEM","delete","INDEXED_DB_ERROR","entryId","getAll","allObjs","add","NAME","VERSION","OfflineManager","_offlineManager","_offlineManager2","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_shakaOfflineProvider","_playkitJsProviders","_dbManager","_dbManager2","downloadStates","DOWNLOADING","PAUSED","RESUMED","ENDED","NOT_SUPPORTED_SOURCE_TYPES","_FakeEventTarget","logLevel","getPrototypeOf","_downloads","_config","_eventManager","EventManager","_setOfflineAdapter","_isDBSynced","_this2","_offlineProvider","ShakaOfflineProvider","listen","PROGRESS_EVENT","e","dispatchEvent","mediaInfo","_this3","id","resolve","sources","dash","Provider","provider","getMediaConfig","mediaConfig","Utils","hasPropertyPath","_removeNotRelevantSources","sourceData","_onError","COULD_NOT_GET_INFO_FROM_MEDIA_PROVIDER","_this4","currentDownload","_recoverEntry","includes","state","pause","update","prepareItemForStorage","PAUSE","PAUSE_FAILED","ENTRY_DOES_NOT_EXIST","_this5","setSessionData","resume","manifestDB","downloadStatus","ob","_this6","RENEW_LICENSE_FAILED","renewLicense","expiration","options","_this7","ENTRY_ALREADY_EXISTS","_doesEntryExists","existsInDB","_addDownloadParam","download","_this8","REQUESTED_ITEM_NOT_FOUND","remove","_this9","promises","getAllDownloads","downloads","forEach","push","all","_this10","getDownloadedMediaConfig","data","_this11","_getReducedDownloadObjectsData","dbDownloads","url","_this12","entry","source","slice","assign","currEntry","recovered","_this13","keys","map","metadata","poster","expectedSize","size","duration","event","FakeEvent","EventType","destroy","FakeEventTarget","_shakaPlayer","_shakaPlayer2","_dtgVideoElement","document","createElement","polyfill","installAll","_dtgShaka","Player","_configureShakaPlayer","addEventListener","_onShakaError","adapterName","adapterVersion","playerVersion","configure","streaming","retryParameters","timeout","maxAttempts","baseDelay","backoffFactor","fuzzFactor","_configureDrmIfNeeded","_initStorage","storage","storeManifest","manifest","offlineUri","Array","isArray","DOWNLOAD_FAILED","RESUME_FAILED","pausePromise","storePormise","storePromise","action","REMOVE_FAILED","detail","code","VIDEO_ERROR_CODE","playerError","severity","category","drmData","servers","val","scheme","licenseUrl","drm","keysToDelete","storeObj","selectedSource","newMediaInfo","getDataByEntry","dbData","_updateDrmDataIfNeeded","currentDownload_","bitrate","arguments","language","tracks","textTracks","filter","track","type","langFilteredTracks","reduce","prev","curr","Math","abs","bandwidth","concat","offline","Storage","configuration","usePersistentLicense","_trackSelectionCallback","_setDownloadProgress","content","progress","details","toArray","arr","promisifyRequest","request","onsuccess","result","onerror","promisifyRequestCall","method","args","apply","promisifyCursorRequestCall","Cursor","proxyProperties","ProxyClass","targetProp","properties","prop","set","proxyRequestMethods","proxyMethods","proxyCursorRequestMethods","Index","index","_index","cursor","_cursor","_request","ObjectStore","_store","Transaction","idbTransaction","_tx","oncomplete","onabort","UpgradeDB","oldVersion","_db","DB","IDBIndex","IDBCursor","methodName","createIndex","IDBObjectStore","IDBTransaction","IDBDatabase","funcName","replace","callback","nativeObject","query","count","items","iterateCursor","continue","exp","version","upgradeCallback","indexedDB","onupgradeneeded","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","global","Logger","logHandler","contextualLoggersByNameMap","bind","scope","func","merge","defineLogLevel","ContextualLogger","defaultContext","context","filterLevel","log","info","newLevel","enabledFor","lvl","invoke","warn","time","label","timeEnd","msgArgs","globalLogger","L","setHandler","createDefaultHandler","formatter","messages","unshift","timerStartTimeByLabelMap","invokeConsoleMethod","hdlr","Function","console","timerLabel","Date","getTime"],"mappings":"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","file":"playkit-offline-manager.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"playkit-js\"), require(\"shaka-player\"), require(\"playkit-js-providers\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"playkit-js\", \"shaka-player\", \"playkit-js-providers\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OfflineManager\"] = factory(require(\"playkit-js\"), require(\"shaka-player\"), require(\"playkit-js-providers\"));\n\telse\n\t\troot[\"KalturaPlayer\"] = root[\"KalturaPlayer\"] || {}, root[\"KalturaPlayer\"][\"OfflineManager\"] = factory(root[\"KalturaPlayer\"][\"core\"], root[\"KalturaPlayer\"][\"shaka\"], root[\"KalturaPlayer\"][\"providers\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_9__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"playkit-js\"), require(\"shaka-player\"), require(\"playkit-js-providers\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"playkit-js\", \"shaka-player\", \"playkit-js-providers\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OfflineManager\"] = factory(require(\"playkit-js\"), require(\"shaka-player\"), require(\"playkit-js-providers\"));\n\telse\n\t\troot[\"KalturaPlayer\"] = root[\"KalturaPlayer\"] || {}, root[\"KalturaPlayer\"][\"OfflineManager\"] = factory(root[\"KalturaPlayer\"][\"core\"], root[\"KalturaPlayer\"][\"shaka\"], root[\"KalturaPlayer\"][\"providers\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_9__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setLogLevel = exports.getLogLevel = exports.LogLevel = undefined;\n\nvar _jsLogger = __webpack_require__(8);\n\nvar JsLogger = _interopRequireWildcard(_jsLogger);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar LogLevel = {\n  DEBUG: JsLogger.DEBUG,\n  INFO: JsLogger.INFO,\n  TIME: JsLogger.TIME,\n  WARN: JsLogger.WARN,\n  ERROR: JsLogger.ERROR,\n  OFF: JsLogger.OFF\n};\n\n\nJsLogger.useDefaults({ defaultLevel: JsLogger.ERROR });\n\n/**\n * get a logger\n * @param {?string} name - the logger name\n * @returns {Object} - the logger class\n */\nfunction getLogger(name) {\n  if (!name) {\n    return JsLogger;\n  }\n  return JsLogger.get(name);\n}\n\n/**\n * get the log level\n * @param {?string} name - the logger name\n * @returns {LogLevelObject} - the log level\n */\nfunction getLogLevel(name) {\n  return getLogger(name).getLevel();\n}\n\n/**\n * sets the logger level\n * @param {LogLevelObject} level - the log level\n * @param {?string} name - the logger name\n * @returns {void}\n */\nfunction setLogLevel(level, name) {\n  getLogger(name).setLevel(level);\n}\n\nexports.default = getLogger;\nexports.LogLevel = LogLevel;\nexports.getLogLevel = getLogLevel;\nexports.setLogLevel = setLogLevel;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _idb = __webpack_require__(7);\n\nvar _idb2 = _interopRequireDefault(_idb);\n\nvar _logger = __webpack_require__(0);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _playkitJs = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar KEY_PATH = 'entryId';\nvar ENTRIES_MAP_STORE_NAME = 'entriesMap';\nvar DB_NAME = 'offline-manager';\n\n/**\n * Your class description.\n * @classdesc\n */\n\nvar DBManager = function () {\n  /**\n   * @constructor\n   * @param {Object} config - The plugin config.\n   */\n  function DBManager(config) {\n    _classCallCheck(this, DBManager);\n\n    DBManager._logger.debug('DBManager created');\n    if (!('indexedDB' in window)) {\n      // console.log('This browser doesn\\'t support IndexedDB');\n      return;\n    }\n    this.config = config;\n    this.open(DB_NAME);\n  }\n\n  _createClass(DBManager, [{\n    key: 'open',\n    value: function open(store) {\n      this.dbPromise = _idb2.default.open(store, 1, function (upgradeDb) {\n        DBManager._logger.debug('open');\n        if (!upgradeDb.objectStoreNames.contains(ENTRIES_MAP_STORE_NAME)) {\n          upgradeDb.createObjectStore(ENTRIES_MAP_STORE_NAME, { keyPath: KEY_PATH });\n        }\n      });\n    }\n  }, {\n    key: 'add',\n    value: function add(storeName, key, item) {\n      var _this = this;\n\n      return this.dbPromise.then(function (db) {\n        DBManager._logger.debug('add');\n        var tx = db.transaction(storeName, 'readwrite');\n        var store = tx.objectStore(storeName);\n        _this._addConfigToItem(item);\n        item[KEY_PATH] = key;\n        store.put(item);\n        return tx.complete;\n      }).catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.CANNOT_ADD_ITEM, error));\n      });\n    }\n  }, {\n    key: 'remove',\n    value: function remove(storeName, key) {\n      return this.dbPromise.then(function (db) {\n        DBManager._logger.debug('remove');\n        var tx = db.transaction(storeName, 'readwrite');\n        tx.objectStore(storeName).delete(key);\n        return tx.complete;\n      }).catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.INDEXED_DB_ERROR, error));\n      });\n    }\n  }, {\n    key: 'get',\n    value: function get(storeName, entryId) {\n      return this.dbPromise.then(function (db) {\n        DBManager._logger.debug('get', entryId);\n        return db.transaction(storeName).objectStore(storeName).get(entryId);\n      }).then(function (obj) {\n        return obj;\n      }).catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.INDEXED_DB_ERROR, error));\n      });\n    }\n  }, {\n    key: 'getAll',\n    value: function getAll(storeName) {\n      return this.dbPromise.then(function (db) {\n        DBManager._logger.debug('getAll');\n        return db.transaction(storeName).objectStore(storeName).getAll();\n      }).then(function (allObjs) {\n        return allObjs;\n      }).catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.INDEXED_DB_ERROR, error));\n      });\n    }\n  }, {\n    key: 'removeAll',\n    value: function removeAll(store) {\n      return store; //TODO implement\n    }\n  }, {\n    key: 'update',\n    value: function update(store, key, value) {\n      DBManager._logger.debug('update');\n      return this.add(store, key, value);\n    }\n  }, {\n    key: '_addConfigToItem',\n    value: function _addConfigToItem(item) {\n      for (var key in this.config) {\n        item[key] = this.config[key];\n      }\n    }\n  }]);\n\n  return DBManager;\n}();\n\nDBManager._logger = (0, _logger2.default)('DBManager');\nexports.default = DBManager;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NAME = exports.VERSION = exports.OfflineManager = undefined;\n\nvar _offlineManager = __webpack_require__(4);\n\nvar _offlineManager2 = _interopRequireDefault(_offlineManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _offlineManager2.default;\nexports.OfflineManager = _offlineManager2.default;\nexports.VERSION = \"1.2.0\";\nexports.NAME = \"playkit-js-offline-manager\";\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shakaOfflineProvider = __webpack_require__(5);\n\nvar _playkitJsProviders = __webpack_require__(9);\n\nvar _playkitJs = __webpack_require__(1);\n\nvar _logger = __webpack_require__(0);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _dbManager = __webpack_require__(2);\n\nvar _dbManager2 = _interopRequireDefault(_dbManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar downloadStates = {\n  DOWNLOADING: 'downloading',\n  PAUSED: 'paused',\n  RESUMED: 'resumed',\n  ENDED: 'ended',\n  ERROR: 'error'\n};\n\nvar ENTRIES_MAP_STORE_NAME = 'entriesMap';\n\nvar DOWNLOAD_PARAM = '?playbackType=offline';\n\nvar NOT_SUPPORTED_SOURCE_TYPES = ['hls', 'progressive'];\n\nvar SUPPORTED_SOURCE = 'dash';\n/**\n * Your class description.\n * @classdesc\n */\n\nvar OfflineManager = function (_FakeEventTarget) {\n  _inherits(OfflineManager, _FakeEventTarget);\n\n  _createClass(OfflineManager, null, [{\n    key: 'isValid',\n\n\n    /**\n     * TODO: Define under what conditions the plugin is valid.\n     * @static\n     * @public\n     * @returns {boolean} - Whether the plugin is valid.\n     */\n    value: function isValid() {\n      return true;\n    }\n\n    /**\n     * @constructor\n     * @param {Object} config - The plugin config.\n     */\n\n  }]);\n\n  function OfflineManager(config) {\n    _classCallCheck(this, OfflineManager);\n\n    if (config.logLevel && _logger.LogLevel[config.logLevel]) {\n      (0, _logger.setLogLevel)(_logger.LogLevel[config.logLevel]);\n    }\n    OfflineManager._logger.debug('offline manager created');\n\n    var _this = _possibleConstructorReturn(this, (OfflineManager.__proto__ || Object.getPrototypeOf(OfflineManager)).call(this));\n\n    if (_this._downloads) {\n      return _possibleConstructorReturn(_this);\n    }\n    _this._downloads = {};\n    _this._config = config;\n    _this._eventManager = new _playkitJs.EventManager();\n    _this._dbManager = new _dbManager2.default({});\n    _this._setOfflineAdapter();\n    _this._isDBSynced = false;\n    return _this;\n  }\n\n  _createClass(OfflineManager, [{\n    key: '_setOfflineAdapter',\n    value: function _setOfflineAdapter() {\n      var _this2 = this;\n\n      this._offlineProvider = new _shakaOfflineProvider.ShakaOfflineProvider(this._downloads, this._config);\n      this._eventManager.listen(this._offlineProvider, _shakaOfflineProvider.PROGRESS_EVENT, function (e) {\n        _this2.dispatchEvent(e);\n      });\n    }\n\n    /**\n     * This function gets the configuration (and info) from the provider.\n     * @param mediaInfo\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: 'getMediaConfig',\n    value: function getMediaConfig(mediaInfo) {\n      var _this3 = this;\n\n      OfflineManager._logger.debug('get media info started', mediaInfo.id);\n      return new Promise(function (resolve) {\n        if (_this3._downloads[mediaInfo.id]) {\n          return resolve(_this3._downloads[mediaInfo.id].sources.dash[0]);\n        }\n        var provider = new _playkitJsProviders.Provider(_this3._config.provider);\n        return provider.getMediaConfig(mediaInfo).then(function (mediaConfig) {\n          if (_playkitJs.Utils.Object.hasPropertyPath(mediaConfig, 'sources.dash') && mediaConfig.sources.dash.length > 0) {\n            mediaConfig = _this3._removeNotRelevantSources(mediaConfig);\n            var sourceData = mediaConfig.sources.dash[0];\n            sourceData.id = mediaConfig.sources.id;\n            _this3._downloads[mediaConfig.sources.id] = mediaConfig;\n            OfflineManager._logger.debug('get media info ended');\n            return resolve(sourceData);\n          } else {\n            _this3._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.COULD_NOT_GET_INFO_FROM_MEDIA_PROVIDER));\n          }\n        });\n      });\n    }\n\n    /**\n     * This function pauses a download\n     * @param entryId\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause(entryId) {\n      var _this4 = this;\n\n      return new Promise(function (resolve) {\n        OfflineManager._logger.debug('pause start', entryId);\n        var currentDownload = _this4._downloads[entryId];\n        if (!currentDownload) {\n          _this4._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.ENTRY_DOES_NOT_EXIST, entryId)); //TODO LOG THIS (until background fetch is here)\n        } else {\n          _this4._recoverEntry(entryId);\n          if ([downloadStates.DOWNLOADING, downloadStates.RESUMED].includes(currentDownload.state)) {\n            return _this4._offlineProvider.pause(entryId).then(function () {\n              currentDownload.state = downloadStates.PAUSED;\n              return _this4._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, _this4._offlineProvider.prepareItemForStorage(currentDownload)).then(function () {\n                OfflineManager._logger.debug('paused ended', entryId);\n                resolve({\n                  entryId: entryId,\n                  state: downloadStates.PAUSE\n                });\n              });\n            }).catch(function (error) {\n              _this4._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.PAUSE_FAILED, error));\n            });\n          } else {\n            return resolve();\n          }\n        }\n      });\n    }\n\n    /**\n     * This function resumes a download\n     * @param entryId\n     * @returns {Promise<*>}\n     */\n\n  }, {\n    key: 'resume',\n    value: function resume(entryId) {\n      var _this5 = this;\n\n      OfflineManager._logger.debug('resume started', entryId);\n      return this._offlineProvider.setSessionData(entryId).then(function () {\n        var currentDownload = _this5._downloads[entryId];\n        _this5._recoverEntry(entryId);\n        if (currentDownload.state === downloadStates.PAUSED) {\n          currentDownload.state = downloadStates.RESUMED;\n          return _this5._offlineProvider.resume(entryId).then(function (manifestDB) {\n            currentDownload.state = [manifestDB.downloadStatus, manifestDB.ob].includes(downloadStates.ENDED) ? downloadStates.ENDED : downloadStates.PAUSED;\n            _this5._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, _this5._offlineProvider.prepareItemForStorage(currentDownload)).then(function () {\n              OfflineManager._logger.debug('resume ended / paused', entryId);\n              return Promise.resolve({\n                state: currentDownload.state,\n                entryId: entryId\n              });\n            });\n          });\n        }\n      }).catch(function (error) {\n        _this5._onError(error);\n      });\n    }\n\n    /**\n     * This function gets an entryId and renew it's DRM license from the server\n     * @param entryId\n     * @returns {Promise<T>}\n     */\n\n  }, {\n    key: 'renewLicense',\n    value: function renewLicense(entryId) {\n      var _this6 = this;\n\n      OfflineManager._logger.debug('renew license started', entryId);\n      var provider = new _playkitJsProviders.Provider(this._config.provider);\n      return provider.getMediaConfig({\n        entryId: entryId\n      }).then(function (mediaConfig) {\n        if (!_playkitJs.Utils.Object.hasPropertyPath(mediaConfig, 'sources.dash') && mediaConfig.sources.dash.length > 0) {\n          _this6._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.RENEW_LICENSE_FAILED, 'not enough data from the media provider'));\n        }\n        return _this6._offlineProvider.setSessionData(entryId, mediaConfig).then(function () {\n          var currentDownload = _this6._downloads[entryId];\n          if (currentDownload.state === downloadStates.ENDED) {\n            _this6._offlineProvider.renewLicense(entryId).then(function (expiration) {\n              _this6._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, _this6._offlineProvider.prepareItemForStorage(currentDownload)).then(function () {\n                OfflineManager._logger.debug('renew license ended', entryId);\n                return Promise.resolve({\n                  state: currentDownload.state,\n                  entryId: entryId,\n                  expiration: expiration\n                });\n              });\n            });\n          }\n        });\n      }).catch(function (error) {\n        _this6._onError(error);\n      });\n    }\n  }, {\n    key: 'download',\n    value: function download(entryId, options) {\n      var _this7 = this;\n\n      return new Promise(function (resolve) {\n        OfflineManager._logger.debug('download start', entryId);\n        var currentDownload = _this7._downloads[entryId];\n        if (currentDownload.state) {\n          _this7._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.ENTRY_ALREADY_EXISTS, entryId));\n          return;\n        }\n        _this7._doesEntryExists(entryId).then(function (existsInDB) {\n          if (existsInDB) {\n            _this7._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.ENTRY_ALREADY_EXISTS, entryId));\n            return;\n          }\n          currentDownload['state'] = downloadStates.DOWNLOADING;\n          _this7._addDownloadParam(entryId);\n          _this7._offlineProvider.download(entryId, options).then(_this7._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, _this7._offlineProvider.prepareItemForStorage(currentDownload))).then(function () {\n            OfflineManager._logger.debug('download ended / paused', entryId);\n            resolve({\n              state: currentDownload.state,\n              entryId: entryId\n            });\n          }).catch(function (error) {\n            return _this7._onError(error);\n          });\n        });\n      });\n    }\n  }, {\n    key: 'remove',\n    value: function remove(entryId) {\n      var _this8 = this;\n\n      OfflineManager._logger.debug('remove start', entryId);\n      return this._offlineProvider.setSessionData(entryId).then(function () {\n        var currentDownload = _this8._downloads[entryId];\n        if (!currentDownload.state) {\n          _this8._onError(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.REQUESTED_ITEM_NOT_FOUND));\n        }\n        _this8._offlineProvider.remove(entryId).then(function () {\n          _this8._dbManager.remove(ENTRIES_MAP_STORE_NAME, entryId).then(function () {\n            delete _this8._downloads[entryId];\n            OfflineManager._logger.debug('remove ended', entryId);\n            return Promise.resolve({\n              state: currentDownload.state,\n              entryId: entryId\n            });\n          });\n        });\n      }).catch(function (error) {\n        return _this8._onError(error);\n      });\n    }\n  }, {\n    key: 'removeAll',\n    value: function removeAll() {\n      var _this9 = this;\n\n      var promises = [];\n      return this.getAllDownloads().then(function (downloads) {\n        downloads.forEach(function (download) {\n          promises.push(_this9.remove(download.sources.id));\n        });\n        _this9._downloads = {};\n        return Promise.all(promises);\n      });\n    }\n  }, {\n    key: 'pauseAll',\n    value: function pauseAll() {\n      var _this10 = this;\n\n      var promises = [];\n      return this.getAllDownloads().then(function (downloads) {\n        downloads.forEach(function (download) {\n          promises.push(_this10.pause(download.sources.id));\n        });\n        return Promise.all(promises);\n      });\n    }\n  }, {\n    key: 'getExpiration',\n    value: function getExpiration(entryId) {\n      return this.getDownloadedMediaConfig(entryId).then(function (data) {\n        return data.expiration;\n      });\n    }\n\n    /**\n     * Getting the full media config of an entry from the indexed db. It contains the full provider info\n     * the status of the download, actual size of the entry, expected size (full size) and drm expiration date.\n     * @param entryId\n     * @returns {*}\n     */\n\n  }, {\n    key: 'getDownloadedMediaConfig',\n    value: function getDownloadedMediaConfig(entryId) {\n      OfflineManager._logger.debug('getDownloadedMediaConfig', entryId);\n      return this._dbManager.get(ENTRIES_MAP_STORE_NAME, entryId);\n    }\n\n    /**\n     * Getting all the in progress, ended, resumed, paused and ended downloads.\n     * @returns {Promise<Array<Object>>}\n     */\n\n  }, {\n    key: 'getAllDownloads',\n    value: function getAllDownloads() {\n      var _this11 = this;\n\n      if (this._isDBSynced) {\n        return Promise.resolve(this._getReducedDownloadObjectsData());\n      }\n      return this._dbManager.getAll(ENTRIES_MAP_STORE_NAME).then(function (dbDownloads) {\n        _this11._isDBSynced = true;\n        dbDownloads.forEach(function (download) {\n          var entryId = download.sources.id;\n          if (!_this11._downloads[entryId]) {\n            _this11._downloads[entryId] = download;\n            _this11._recoverEntry(entryId);\n          }\n        });\n        return Promise.resolve(_this11._getReducedDownloadObjectsData());\n      });\n    }\n\n    /**\n     * add parameter to the manifest url so the server will know it's only for downloading and not playing (stats purpose)\n     * @param entryId\n     * @private\n     */\n\n  }, {\n    key: '_addDownloadParam',\n    value: function _addDownloadParam(entryId) {\n      var currentDownload = this._downloads[entryId];\n      currentDownload.sources.dash[0].url = currentDownload.sources.dash[0].url + DOWNLOAD_PARAM;\n    }\n\n    /**\n     * checking if an entry exists already in the DB.\n     * @param entryId\n     * @returns {Promise<any>}\n     * @private\n     */\n\n  }, {\n    key: '_doesEntryExists',\n    value: function _doesEntryExists(entryId) {\n      var _this12 = this;\n\n      return new Promise(function (resolve) {\n        return _this12.getDownloadedMediaConfig(entryId).then(function (entry) {\n          resolve(entry && entry.state);\n        });\n      });\n    }\n\n    /**\n     * Removing  sources that we are not downloading from the media config\n     * currently as we are having only dash adapter, we will take the first dash source.\n     * @param {Object} mediaConfig\n     * @private\n     */\n\n  }, {\n    key: '_removeNotRelevantSources',\n    value: function _removeNotRelevantSources(mediaConfig) {\n      for (var key in mediaConfig.sources) {\n        var source = mediaConfig.sources[key];\n        if (NOT_SUPPORTED_SOURCE_TYPES.includes(key)) {\n          delete mediaConfig.sources[key];\n        } else if (key === SUPPORTED_SOURCE) {\n          source = source.slice(1);\n        }\n      }\n      return Object.assign({}, mediaConfig);\n    }\n\n    /**\n     * The indexed db can contain corrupted values regarding a download if something goes wrong.\n     * for example, it can has a \"downloading\" state while there is nothing downloaded,\n     * if a download was interrupted unexpectedly (browser crash e.g).\n     * this function handles this.\n     * @private\n     */\n\n  }, {\n    key: '_recoverEntry',\n    value: function _recoverEntry(entryId) {\n      var currEntry = this._downloads[entryId];\n      if (!currEntry || currEntry.recovered) {\n        return;\n      } else {\n        if (currEntry.state === downloadStates.DOWNLOADING || currEntry.state === downloadStates.RESUMED) {\n          currEntry.state = downloadStates.PAUSED;\n        }\n        currEntry.recovered = true;\n      }\n    }\n\n    /**\n     * get a reduced and normalized version of the provider data.\n     * @returns {Array<Object>}\n     * @private\n     */\n\n  }, {\n    key: '_getReducedDownloadObjectsData',\n    value: function _getReducedDownloadObjectsData() {\n      var _this13 = this;\n\n      return Object.keys(this._downloads).map(function (i) {\n        var item = _this13._downloads[i];\n        return {\n          id: item.sources.id,\n          metadata: item.sources.metadata,\n          poster: item.sources.poster,\n          expectedSize: item.expectedSize,\n          size: item.size,\n          expiration: item.expiration,\n          duration: item.sources.duration,\n          state: item.state\n        };\n      });\n    }\n\n    /**\n     * Error handler, dispatches an error object\n     * @param error\n     * @private\n     */\n\n  }, {\n    key: '_onError',\n    value: function _onError(error) {\n      var event = new _playkitJs.FakeEvent(_playkitJs.EventType.ERROR, error);\n      this.dispatchEvent(event);\n    }\n\n    /**\n     * TODO: Define the destroy logic of your plugin.\n     * Destroys the plugin.\n     * @override\n     * @public\n     * @returns {void}\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      // Write logic\n      this._eventManager.destroy();\n    }\n\n    /**\n     * TODO: Define the reset logic of your plugin.\n     * Resets the plugin.\n     * @override\n     * @public\n     * @returns {void}\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      // Write logic\n    }\n  }]);\n\n  return OfflineManager;\n}(_playkitJs.FakeEventTarget);\n\nOfflineManager._logger = (0, _logger2.default)('OfflineManager');\nexports.default = OfflineManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ShakaOfflineProvider = exports.PROGRESS_EVENT = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shakaPlayer = __webpack_require__(6);\n\nvar _shakaPlayer2 = _interopRequireDefault(_shakaPlayer);\n\nvar _dbManager = __webpack_require__(2);\n\nvar _dbManager2 = _interopRequireDefault(_dbManager);\n\nvar _playkitJs = __webpack_require__(1);\n\nvar _logger = __webpack_require__(0);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //flow\n\n\nvar downloadStates = {\n  DOWNLOADING: 'downloading',\n  PAUSED: 'paused',\n  RESUMED: 'resumed',\n  ENDED: 'ended'\n};\n\nvar ENTRIES_MAP_STORE_NAME = 'entriesMap';\n\nvar PROGRESS_EVENT = exports.PROGRESS_EVENT = 'progress';\n\nvar ShakaOfflineProvider = exports.ShakaOfflineProvider = function (_FakeEventTarget) {\n  _inherits(ShakaOfflineProvider, _FakeEventTarget);\n\n  function ShakaOfflineProvider(downloads) {\n    _classCallCheck(this, ShakaOfflineProvider);\n\n    var _this = _possibleConstructorReturn(this, (ShakaOfflineProvider.__proto__ || Object.getPrototypeOf(ShakaOfflineProvider)).call(this));\n\n    ShakaOfflineProvider._logger.debug('ShakaOfflineProvider created');\n    _this._dtgVideoElement = document.createElement('video');\n    _shakaPlayer2.default.polyfill.installAll();\n    _this._dtgShaka = new _shakaPlayer2.default.Player(_this._dtgVideoElement);\n    _this._configureShakaPlayer();\n    _this._dtgShaka.addEventListener(_playkitJs.EventType.ERROR, _this._onShakaError);\n    // todo remove this as part of the classes refactor, adding the offline provider config should be on \"item.prepareforstorage()\"\n    _this._dbManager = new _dbManager2.default({\n      adapterName: 'shaka',\n      adapterVersion: \"\", //player.version,\n      playerVersion: \"\" //player.version\n    });\n    _this._downloads = downloads;\n    return _this;\n  }\n\n  _createClass(ShakaOfflineProvider, [{\n    key: '_configureShakaPlayer',\n    value: function _configureShakaPlayer() {\n      this._dtgShaka.configure({\n        streaming: {\n          retryParameters: {\n            timeout: 0, // timeout in ms, after which we abort a request; 0 means never\n            maxAttempts: 100, // the maximum number of requests before we fail\n            baseDelay: 1000, // the base delay in ms between retries\n            backoffFactor: 2, // the multiplicative backoff factor between retries\n            fuzzFactor: 0.5 // the fuzz factor to apply to each retry delay\n          }\n        }\n      });\n    }\n  }, {\n    key: 'download',\n    value: function download(entryId, options) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        ShakaOfflineProvider._logger.debug('download', entryId);\n        var currentDownload = _this2._downloads[entryId];\n        _this2._configureDrmIfNeeded(entryId);\n        currentDownload['storage'] = _this2._initStorage(entryId, options);\n        // first store manifest\n        return currentDownload.storage.storeManifest(currentDownload.sources.dash[0].url, {}).then(function (manifest) {\n          ShakaOfflineProvider._logger.debug('after storage.storeManifest', entryId);\n          currentDownload.state = downloadStates.DOWNLOADING;\n          currentDownload.recovered = true;\n          currentDownload.sources.dash[0].url = manifest.offlineUri;\n          currentDownload.expiration = manifest.expiration;\n          currentDownload.expectedSize = manifest.expectedSize;\n          currentDownload.size = 0;\n          return _this2._dbManager.add(ENTRIES_MAP_STORE_NAME, entryId, _this2.prepareItemForStorage(currentDownload)).then(function () {\n            return currentDownload.storage.download(currentDownload.sources.dash[0].url).then(function (manifest) {\n              currentDownload.size = manifest.size;\n              currentDownload.state = manifest.downloadStatus;\n              resolve();\n            });\n          });\n        }).catch(function (error) {\n          // Shaka error's data parameter is an array, we want to normalize it.\n          var data = Array.isArray(error.data) ? error.data[0] : error.data;\n          return reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.DOWNLOAD_FAILED, data));\n        });\n      });\n    }\n  }, {\n    key: 'pause',\n    value: function pause(entryId) {\n      ShakaOfflineProvider._logger.debug('pause', entryId);\n      var currentDownload = this._downloads[entryId];\n      return currentDownload.storage.pause().catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.PAUSE_FAILED, error.data && error.data[0]));\n      });\n    }\n  }, {\n    key: 'resume',\n    value: function resume(entryId) {\n      ShakaOfflineProvider._logger.debug('resume', entryId);\n      var currentDownload = this._downloads[entryId];\n      return currentDownload.storage.download(currentDownload.sources.dash[0].url).catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.RESUME_FAILED, error.data && error.data[0]));\n      });\n    }\n  }, {\n    key: 'remove',\n    value: function remove(entryId) {\n      var _this3 = this;\n\n      ShakaOfflineProvider._logger.debug('remove', entryId);\n      var currentDownload = this._downloads[entryId];\n      // in case of removing a download in progress, we have to pause the download and wait for the\n      // store promise to be resolved. Only then we will have the shaka offline storage uri, so it can be deleted\n      // from the shaka indexed db as well.\n      var pausePromise = currentDownload.state === downloadStates.ENDED ? Promise.resolve() : this.pause(entryId);\n      var storePormise = currentDownload.storePromise || Promise.resolve();\n      return Promise.all([pausePromise, storePormise]).then(function () {\n        currentDownload.storage = _this3._initStorage(entryId, { action: 'remove' });\n        return currentDownload.storage.remove(currentDownload.sources.dash[0].url);\n      }).catch(function (error) {\n        return Promise.reject(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.STORAGE, _playkitJs.Error.Code.REMOVE_FAILED, error.data && error.data[0]));\n      });\n    }\n  }, {\n    key: 'renewLicense',\n    value: function renewLicense(entryId) {\n      ShakaOfflineProvider._logger.debug('renewLicense', entryId);\n      var currentDownload = this._downloads[entryId];\n      this._configureDrmIfNeeded(entryId);\n      currentDownload['storage'] = this._initStorage(entryId, {});\n      return currentDownload.storage.renewLicense(currentDownload.sources.dash[0].url).then(function (manifestDB) {\n        currentDownload.expiration = manifestDB.expiration;\n        return Promise.resolve(manifestDB.expiration);\n      });\n    }\n  }, {\n    key: 'getDataByEntry',\n    value: function getDataByEntry(entryId) {\n      return this._dbManager.get(ENTRIES_MAP_STORE_NAME, entryId);\n    }\n  }, {\n    key: 'getAllDownloads',\n    value: function getAllDownloads() {\n      return this._dbManager.getAll(ENTRIES_MAP_STORE_NAME);\n    }\n  }, {\n    key: '_onShakaError',\n    value: function _onShakaError(event) {\n      if (event && event.detail) {\n        var error = event.detail;\n        //currently we don't handle video element errors on the offline shaka\n        if (error.code === this.VIDEO_ERROR_CODE) {\n          ShakaOfflineProvider._logger.error(error);\n          return;\n        }\n        var playerError = new _playkitJs.Error(error.severity, error.category, error.code, error.data);\n        ShakaOfflineProvider._logger.error(playerError);\n        this.dispatchEvent(new _playkitJs.FakeEvent(_playkitJs.EventType.ERROR, playerError));\n      }\n    }\n  }, {\n    key: '_configureDrmIfNeeded',\n    value: function _configureDrmIfNeeded(entryId) {\n      ShakaOfflineProvider._logger.debug('configure drm if needed', entryId);\n      var currentDownload = this._downloads[entryId];\n      var drmData = currentDownload.sources.dash[0].drmData;\n      if (drmData) {\n        var servers = {};\n        drmData.forEach(function (val) {\n          servers[val.scheme] = val.licenseUrl;\n        });\n        this._dtgShaka.configure({ 'drm': { 'servers': servers } });\n      } else {\n        this._dtgShaka.configure({});\n      }\n    }\n  }, {\n    key: 'prepareItemForStorage',\n    value: function prepareItemForStorage(object) {\n      var keysToDelete = [\"storage\", \"url\", \"mimetype\", \"storePromise\", \"recovered\"];\n      var storeObj = Object.assign({}, object);\n      for (var key in storeObj) {\n        if (keysToDelete.includes(key)) {\n          delete storeObj[key];\n        }\n      }\n      var selectedSource = object.sources.dash[0];\n      selectedSource['localSource'] = true;\n      object.sources.dash = [selectedSource]; // storing only one relevant source\n      return storeObj;\n    }\n\n    /**\n     * This function makes an entry ready to be used by the download manager.\n     * It gets the entry data from DB, it refreshes the drm data and create a shaka storage\n     * object if one was not created already.\n     * @param entryId\n     * @param newMediaInfo - new mediaInfo from the server (used for renewDRM) TODO: pass only drm data?\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: 'setSessionData',\n    value: function setSessionData(entryId, newMediaInfo) {\n      var _this4 = this;\n\n      ShakaOfflineProvider._logger.debug('set session data', entryId);\n      return new Promise(function (resolve, reject) {\n        if (_this4._downloads[entryId]) {\n          return resolve();\n        }\n        return _this4.getDataByEntry(entryId).then(function (dbData) {\n          var data = Object.assign({}, dbData);\n          _this4._downloads[entryId] = data;\n          return resolve();\n        }).catch(function (error) {\n          return reject(error);\n        });\n      }).then(function () {\n        var currentDownload = _this4._downloads[entryId];\n        currentDownload.storage = currentDownload.storage ? currentDownload.storage : _this4._initStorage(entryId);\n        _this4._updateDrmDataIfNeeded(entryId, newMediaInfo);\n        return Promise.resolve();\n      }).catch(function (error) {\n        return Promise.reject(error);\n      });\n    }\n  }, {\n    key: '_updateDrmDataIfNeeded',\n    value: function _updateDrmDataIfNeeded(entryId, newMediaInfo) {\n      if (!newMediaInfo) {\n        return;\n      }\n      var currentDownload_ = this._downloads[entryId];\n      if (currentDownload_.sources.dash[0].drmData && newMediaInfo.sources.dash[0].drmData) {\n        currentDownload_.sources.dash[0].drmData = newMediaInfo.sources.dash[0].drmData;\n      }\n    }\n  }, {\n    key: '_trackSelectionCallback',\n    value: function _trackSelectionCallback() {\n      var bitrate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      return function (tracks) {\n        var textTracks = tracks.filter(function (track) {\n          return track.type === 'text';\n        });\n        var langFilteredTracks = tracks.filter(function (track) {\n          return track.language === language && track.type !== 'text';\n        });\n        tracks = langFilteredTracks.length > 0 ? langFilteredTracks : tracks;\n        var closest = tracks.reduce(function (prev, curr) {\n          return Math.abs(curr.bandwidth - bitrate) < Math.abs(prev.bandwidth - bitrate) ? curr : prev;\n        });\n        return [closest].concat(textTracks);\n      };\n    }\n  }, {\n    key: '_initStorage',\n    value: function _initStorage(entryId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      ShakaOfflineProvider._logger.debug('init storage', entryId);\n      var storage = new _shakaPlayer2.default.offline.Storage(this._dtgShaka);\n      var configuration = {\n        usePersistentLicense: true\n      };\n      if (options.bitrate || options.language) {\n        configuration[\"trackSelectionCallback\"] = this._trackSelectionCallback(options.bitrate, options.language);\n      }\n      if (!options.action || options.action !== 'remove') {\n        configuration[\"progressCallback\"] = this._setDownloadProgress(entryId);\n      }\n      storage.configure(configuration);\n      return storage;\n    }\n  }, {\n    key: '_setDownloadProgress',\n    value: function _setDownloadProgress(entryId) {\n      var _this5 = this;\n\n      ShakaOfflineProvider._logger.debug('set download progress', entryId);\n      return function (content, progress) {\n        var currentDownload_ = _this5._downloads[entryId];\n        currentDownload_.size = content.size;\n        _this5._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, _this5.prepareItemForStorage(currentDownload_));\n        var event = new _playkitJs.FakeEvent(PROGRESS_EVENT, {\n          detail: {\n            content: content,\n            progress: progress * 100,\n            entryId: entryId\n          },\n          details: {\n            content: content,\n            progress: progress * 100,\n            entryId: entryId\n          }\n        });\n        _this5.dispatchEvent(event);\n      };\n    }\n  }]);\n\n  return ShakaOfflineProvider;\n}(_playkitJs.FakeEventTarget);\n\nShakaOfflineProvider._logger = (0, _logger2.default)('ShakaOfflineProvider');\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n(function() {\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  var exp = {\n    open: function(name, version, upgradeCallback) {\n      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n      var request = p.request;\n\n      request.onupgradeneeded = function(event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n\n      return p.then(function(db) {\n        return new DB(db);\n      });\n    },\n    delete: function(name) {\n      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n    }\n  };\n\n  if (true) {\n    module.exports = exp;\n    module.exports.default = module.exports;\n  }\n  else {\n    self.idb = exp;\n  }\n}());\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\r\n(function (global) {\r\n\t\"use strict\";\r\n\r\n\t// Top level module for the global, static logger instance.\r\n\tvar Logger = { };\r\n\r\n\t// For those that are at home that are keeping score.\r\n\tLogger.VERSION = \"1.4.1\";\r\n\r\n\t// Function which handles all incoming log messages.\r\n\tvar logHandler;\r\n\r\n\t// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\r\n\tvar contextualLoggersByNameMap = {};\r\n\r\n\t// Polyfill for ES5's Function.bind.\r\n\tvar bind = function(scope, func) {\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t// Super exciting object merger-matron 9000 adding another 100 bytes to your download.\r\n\tvar merge = function () {\r\n\t\tvar args = arguments, target = args[0], key, i;\r\n\t\tfor (i = 1; i < args.length; i++) {\r\n\t\t\tfor (key in args[i]) {\r\n\t\t\t\tif (!(key in target) && args[i].hasOwnProperty(key)) {\r\n\t\t\t\t\ttarget[key] = args[i][key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\t// Helper to define a logging level object; helps with optimisation.\r\n\tvar defineLogLevel = function(value, name) {\r\n\t\treturn { value: value, name: name };\r\n\t};\r\n\r\n\t// Predefined logging levels.\r\n\tLogger.DEBUG = defineLogLevel(1, 'DEBUG');\r\n\tLogger.INFO = defineLogLevel(2, 'INFO');\r\n\tLogger.TIME = defineLogLevel(3, 'TIME');\r\n\tLogger.WARN = defineLogLevel(4, 'WARN');\r\n\tLogger.ERROR = defineLogLevel(8, 'ERROR');\r\n\tLogger.OFF = defineLogLevel(99, 'OFF');\r\n\r\n\t// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\r\n\t// of each other.\r\n\tvar ContextualLogger = function(defaultContext) {\r\n\t\tthis.context = defaultContext;\r\n\t\tthis.setLevel(defaultContext.filterLevel);\r\n\t\tthis.log = this.info;  // Convenience alias.\r\n\t};\r\n\r\n\tContextualLogger.prototype = {\r\n\t\t// Changes the current logging level for the logging instance.\r\n\t\tsetLevel: function (newLevel) {\r\n\t\t\t// Ensure the supplied Level object looks valid.\r\n\t\t\tif (newLevel && \"value\" in newLevel) {\r\n\t\t\t\tthis.context.filterLevel = newLevel;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// Gets the current logging level for the logging instance\r\n\t\tgetLevel: function () {\r\n\t\t\treturn this.context.filterLevel;\r\n\t\t},\r\n\r\n\t\t// Is the logger configured to output messages at the supplied level?\r\n\t\tenabledFor: function (lvl) {\r\n\t\t\tvar filterLevel = this.context.filterLevel;\r\n\t\t\treturn lvl.value >= filterLevel.value;\r\n\t\t},\r\n\r\n\t\tdebug: function () {\r\n\t\t\tthis.invoke(Logger.DEBUG, arguments);\r\n\t\t},\r\n\r\n\t\tinfo: function () {\r\n\t\t\tthis.invoke(Logger.INFO, arguments);\r\n\t\t},\r\n\r\n\t\twarn: function () {\r\n\t\t\tthis.invoke(Logger.WARN, arguments);\r\n\t\t},\r\n\r\n\t\terror: function () {\r\n\t\t\tthis.invoke(Logger.ERROR, arguments);\r\n\t\t},\r\n\r\n\t\ttime: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'start' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttimeEnd: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'end' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Invokes the logger callback if it's not being filtered.\r\n\t\tinvoke: function (level, msgArgs) {\r\n\t\t\tif (logHandler && this.enabledFor(level)) {\r\n\t\t\t\tlogHandler(msgArgs, merge({ level: level }, this.context));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Protected instance which all calls to the to level `Logger` module will be routed through.\r\n\tvar globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });\r\n\r\n\t// Configure the global Logger instance.\r\n\t(function() {\r\n\t\t// Shortcut for optimisers.\r\n\t\tvar L = Logger;\r\n\r\n\t\tL.enabledFor = bind(globalLogger, globalLogger.enabledFor);\r\n\t\tL.debug = bind(globalLogger, globalLogger.debug);\r\n\t\tL.time = bind(globalLogger, globalLogger.time);\r\n\t\tL.timeEnd = bind(globalLogger, globalLogger.timeEnd);\r\n\t\tL.info = bind(globalLogger, globalLogger.info);\r\n\t\tL.warn = bind(globalLogger, globalLogger.warn);\r\n\t\tL.error = bind(globalLogger, globalLogger.error);\r\n\r\n\t\t// Don't forget the convenience alias!\r\n\t\tL.log = L.info;\r\n\t}());\r\n\r\n\t// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\r\n\t// object with the supplied log messages and the second being a context object which contains a hash of stateful\r\n\t// parameters which the logging function can consume.\r\n\tLogger.setHandler = function (func) {\r\n\t\tlogHandler = func;\r\n\t};\r\n\r\n\t// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\r\n\t// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\r\n\tLogger.setLevel = function(level) {\r\n\t\t// Set the globalLogger's level.\r\n\t\tglobalLogger.setLevel(level);\r\n\r\n\t\t// Apply this level to all registered contextual loggers.\r\n\t\tfor (var key in contextualLoggersByNameMap) {\r\n\t\t\tif (contextualLoggersByNameMap.hasOwnProperty(key)) {\r\n\t\t\t\tcontextualLoggersByNameMap[key].setLevel(level);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Gets the global logging filter level\r\n\tLogger.getLevel = function() {\r\n\t\treturn globalLogger.getLevel();\r\n\t};\r\n\r\n\t// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\r\n\t// default context and log handler.\r\n\tLogger.get = function (name) {\r\n\t\t// All logger instances are cached so they can be configured ahead of use.\r\n\t\treturn contextualLoggersByNameMap[name] ||\r\n\t\t\t(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));\r\n\t};\r\n\r\n\t// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\r\n\t// write to the window's console object (if present); the optional options object can be used to customise the\r\n\t// formatter used to format each log message.\r\n\tLogger.createDefaultHandler = function (options) {\r\n\t\toptions = options || {};\r\n\r\n\t\toptions.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\r\n\t\t\t// Prepend the logger's name to the log message for easy identification.\r\n\t\t\tif (context.name) {\r\n\t\t\t\tmessages.unshift(\"[\" + context.name + \"]\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\r\n\t\t// that don't offer a native console method.\r\n\t\tvar timerStartTimeByLabelMap = {};\r\n\r\n\t\t// Support for IE8+ (and other, slightly more sane environments)\r\n\t\tvar invokeConsoleMethod = function (hdlr, messages) {\r\n\t\t\tFunction.prototype.apply.call(hdlr, console, messages);\r\n\t\t};\r\n\r\n\t\t// Check for the presence of a logger.\r\n\t\tif (typeof console === \"undefined\") {\r\n\t\t\treturn function () { /* no console */ };\r\n\t\t}\r\n\r\n\t\treturn function(messages, context) {\r\n\t\t\t// Convert arguments object to Array.\r\n\t\t\tmessages = Array.prototype.slice.call(messages);\r\n\r\n\t\t\tvar hdlr = console.log;\r\n\t\t\tvar timerLabel;\r\n\r\n\t\t\tif (context.level === Logger.TIME) {\r\n\t\t\t\ttimerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\r\n\r\n\t\t\t\tif (messages[1] === 'start') {\r\n\t\t\t\t\tif (console.time) {\r\n\t\t\t\t\t\tconsole.time(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttimerStartTimeByLabelMap[timerLabel] = new Date().getTime();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (console.timeEnd) {\r\n\t\t\t\t\t\tconsole.timeEnd(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinvokeConsoleMethod(hdlr, [ timerLabel + ': ' +\r\n\t\t\t\t\t\t\t(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Delegate through to custom warn/error loggers if present on the console.\r\n\t\t\t\tif (context.level === Logger.WARN && console.warn) {\r\n\t\t\t\t\thdlr = console.warn;\r\n\t\t\t\t} else if (context.level === Logger.ERROR && console.error) {\r\n\t\t\t\t\thdlr = console.error;\r\n\t\t\t\t} else if (context.level === Logger.INFO && console.info) {\r\n\t\t\t\t\thdlr = console.info;\r\n\t\t\t\t} else if (context.level === Logger.DEBUG && console.debug) {\r\n\t\t\t\t\thdlr = console.debug;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toptions.formatter(messages, context);\r\n\t\t\t\tinvokeConsoleMethod(hdlr, messages);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t// Configure and example a Default implementation which writes to the `window.console` (if present).  The\r\n\t// `options` hash can be used to configure the default logLevel and provide a custom message formatter.\r\n\tLogger.useDefaults = function(options) {\r\n\t\tLogger.setLevel(options && options.defaultLevel || Logger.DEBUG);\r\n\t\tLogger.setHandler(Logger.createDefaultHandler(options));\r\n\t};\r\n\r\n\t// Export to popular environments boilerplate.\r\n\tif (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (Logger),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t}\r\n\telse if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = Logger;\r\n\t}\r\n\telse {\r\n\t\tLogger._prevLogger = global.Logger;\r\n\r\n\t\tLogger.noConflict = function () {\r\n\t\t\tglobal.Logger = Logger._prevLogger;\r\n\t\t\treturn Logger;\r\n\t\t};\r\n\r\n\t\tglobal.Logger = Logger;\r\n\t}\r\n}(this));\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// playkit-offline-manager.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ade2e548e8819cc0efc1","//@flow\nimport * as JsLogger from 'js-logger';\n\nexport type LogLevelObject = { value: number, name: string };\nexport type LogLevelType = { [level: string]: LogLevelObject };\n\nconst LogLevel: LogLevelType = {\n  DEBUG: JsLogger.DEBUG,\n  INFO: JsLogger.INFO,\n  TIME: JsLogger.TIME,\n  WARN: JsLogger.WARN,\n  ERROR: JsLogger.ERROR,\n  OFF: JsLogger.OFF\n};\n\nJsLogger.useDefaults({defaultLevel: JsLogger.ERROR});\n\n/**\n * get a logger\n * @param {?string} name - the logger name\n * @returns {Object} - the logger class\n */\nfunction getLogger(name?: string): Object {\n  if (!name) {\n    return JsLogger;\n  }\n  return JsLogger.get(name);\n}\n\n/**\n * get the log level\n * @param {?string} name - the logger name\n * @returns {LogLevelObject} - the log level\n */\nfunction getLogLevel(name?: string): LogLevelObject {\n  return getLogger(name).getLevel();\n}\n\n/**\n * sets the logger level\n * @param {LogLevelObject} level - the log level\n * @param {?string} name - the logger name\n * @returns {void}\n */\nfunction setLogLevel(level: LogLevelObject, name?: string): void {\n  getLogger(name).setLevel(level);\n}\n\nexport default getLogger;\nexport {LogLevel, getLogLevel, setLogLevel};\n\n\n\n// WEBPACK FOOTER //\n// ./utils/logger.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":[\"KalturaPlayer\",\"core\"]}\n// module id = 1\n// module chunks = 0","// @flow\nimport idb from 'idb'\nimport getLogger from \"./utils/logger\";\nimport {Error} from 'playkit-js'\n\nconst KEY_PATH: string = 'entryId';\nconst ENTRIES_MAP_STORE_NAME: string = 'entriesMap';\nconst DB_NAME: string = 'offline-manager';\n\n/**\n * Your class description.\n * @classdesc\n */\nexport default class DBManager{\n\n  static _logger: any = getLogger('DBManager');\n  /**\n   * @constructor\n   * @param {Object} config - The plugin config.\n   */\n  constructor(config: Object) {\n    DBManager._logger.debug('DBManager created');\n    if (!('indexedDB' in window)) {\n     // console.log('This browser doesn\\'t support IndexedDB');\n      return;\n    }\n    this.config = config;\n    this.open(DB_NAME);\n  }\n\n  open(store){\n    this.dbPromise = idb.open(store, 1, (upgradeDb)=>{\n      DBManager._logger.debug('open');\n      if (!upgradeDb.objectStoreNames.contains(ENTRIES_MAP_STORE_NAME)) {\n        upgradeDb.createObjectStore(ENTRIES_MAP_STORE_NAME, {keyPath: KEY_PATH});\n      }\n    });\n  }\n\n  add(storeName, key ,item){\n    return this.dbPromise.then(db => {\n      DBManager._logger.debug('add');\n      let tx = db.transaction(storeName, 'readwrite');\n      let store = tx.objectStore(storeName);\n      this._addConfigToItem(item);\n      item[KEY_PATH] = key;\n      store.put(item);\n      return tx.complete;\n    }).catch((error)=> {\n      return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.CANNOT_ADD_ITEM, error));\n    });\n  }\n\n  remove(storeName,key){\n    return this.dbPromise.then(db => {\n      DBManager._logger.debug('remove');\n      const tx = db.transaction(storeName, 'readwrite');\n      tx.objectStore(storeName).delete(key);\n      return tx.complete;\n    }).catch(error => {\n      return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.INDEXED_DB_ERROR, error));\n    });\n  }\n\n  get(storeName, entryId){\n    return this.dbPromise.then(db => {\n      DBManager._logger.debug('get', entryId);\n      return db.transaction(storeName)\n        .objectStore(storeName).get(entryId);\n    }).then(obj =>{\n      return obj;\n    }).catch(error => {\n      return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.INDEXED_DB_ERROR, error));\n    });\n  }\n\n  getAll(storeName){\n    return this.dbPromise.then(db => {\n      DBManager._logger.debug('getAll');\n      return db.transaction(storeName)\n        .objectStore(storeName).getAll();\n    }).then(allObjs => {\n      return allObjs;\n    }).catch(error => {\n      return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.INDEXED_DB_ERROR, error));\n    });\n  }\n\n  removeAll(store){\n    return store; //TODO implement\n  }\n\n  update(store,key,value){\n    DBManager._logger.debug('update');\n    return this.add(store,key,value);\n  }\n\n  _addConfigToItem(item){\n    for (let key in this.config){\n      item[key] = this.config[key];\n    }\n  }\n\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./db-manager.js","// @flow\nimport OfflineManager from './offline-manager'\n\ndeclare var __VERSION__: string;\ndeclare var __NAME__: string;\nexport default OfflineManager;\nexport {OfflineManager}\nexport {__VERSION__ as VERSION, __NAME__ as NAME};\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","// @flow\nimport {ShakaOfflineProvider, PROGRESS_EVENT} from \"./shaka-offline-provider\";\nimport {Provider} from 'playkit-js-providers';\nimport {Utils, FakeEventTarget, EventManager, Error, EventType as EVENTS, FakeEvent} from 'playkit-js';\nimport getLogger, {setLogLevel, LogLevel} from './utils/logger'\nimport DBManager from \"./db-manager\";\n\n\nconst downloadStates = {\n  DOWNLOADING: 'downloading',\n  PAUSED: 'paused',\n  RESUMED: 'resumed',\n  ENDED: 'ended',\n  ERROR: 'error'\n};\n\nconst ENTRIES_MAP_STORE_NAME = 'entriesMap';\n\nconst DOWNLOAD_PARAM = '?playbackType=offline';\n\nconst NOT_SUPPORTED_SOURCE_TYPES = ['hls', 'progressive'];\n\nconst SUPPORTED_SOURCE = 'dash';\n/**\n * Your class description.\n * @classdesc\n */\nexport default class OfflineManager extends FakeEventTarget {\n\n  static _logger: any = getLogger('OfflineManager');\n\n  /**\n   * TODO: Define under what conditions the plugin is valid.\n   * @static\n   * @public\n   * @returns {boolean} - Whether the plugin is valid.\n   */\n  static isValid(): boolean {\n    return true;\n  }\n\n  /**\n   * @constructor\n   * @param {Object} config - The plugin config.\n   */\n  constructor(config) {\n    if (config.logLevel && LogLevel[config.logLevel]) {\n      setLogLevel(LogLevel[config.logLevel]);\n    }\n    OfflineManager._logger.debug('offline manager created');\n    super();\n    if (this._downloads) {\n      return;\n    }\n    this._downloads = {};\n    this._config = config;\n    this._eventManager = new EventManager();\n    this._dbManager = new DBManager({});\n    this._setOfflineAdapter();\n    this._isDBSynced = false;\n  }\n\n  _setOfflineAdapter(): void {\n    this._offlineProvider = new ShakaOfflineProvider(this._downloads, this._config);\n    this._eventManager.listen(this._offlineProvider, PROGRESS_EVENT, (e) => {\n      this.dispatchEvent(e);\n    });\n  }\n\n  /**\n   * This function gets the configuration (and info) from the provider.\n   * @param mediaInfo\n   * @returns {Promise<any>}\n   */\n  getMediaConfig(mediaInfo: Object): Promise<*> {\n    OfflineManager._logger.debug('get media info started', mediaInfo.id);\n    return new Promise((resolve) => {\n      if (this._downloads[mediaInfo.id]) {\n        return resolve(this._downloads[mediaInfo.id].sources.dash[0]);\n      }\n      const provider = new Provider(this._config.provider);\n      return provider.getMediaConfig(mediaInfo)\n        .then(mediaConfig => {\n          if (Utils.Object.hasPropertyPath(mediaConfig, 'sources.dash') && mediaConfig.sources.dash.length > 0) {\n            mediaConfig = this._removeNotRelevantSources(mediaConfig);\n            let sourceData = mediaConfig.sources.dash[0];\n            sourceData.id = mediaConfig.sources.id;\n            this._downloads[mediaConfig.sources.id] = mediaConfig;\n            OfflineManager._logger.debug('get media info ended');\n            return resolve(sourceData);\n          } else {\n            this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.COULD_NOT_GET_INFO_FROM_MEDIA_PROVIDER));\n          }\n        });\n    })\n  }\n\n  /**\n   * This function pauses a download\n   * @param entryId\n   * @returns {Promise<any>}\n   */\n  pause(entryId): Promise<*> {\n    return new Promise((resolve) => {\n      OfflineManager._logger.debug('pause start', entryId);\n      let currentDownload = this._downloads[entryId];\n      if (!currentDownload) {\n        this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.ENTRY_DOES_NOT_EXIST, entryId)); //TODO LOG THIS (until background fetch is here)\n      } else {\n        this._recoverEntry(entryId);\n        if ([downloadStates.DOWNLOADING, downloadStates.RESUMED].includes(currentDownload.state)) {\n          return this._offlineProvider.pause(entryId).then(() => {\n            currentDownload.state = downloadStates.PAUSED;\n            return this._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, this._offlineProvider.prepareItemForStorage(currentDownload)).then(() => {\n              OfflineManager._logger.debug('paused ended', entryId);\n              resolve({\n                entryId: entryId,\n                state: downloadStates.PAUSE\n              });\n            });\n          }).catch((error) => {\n            this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.PAUSE_FAILED, error));\n          });\n        } else {\n          return resolve();\n        }\n      }\n    });\n  }\n\n  /**\n   * This function resumes a download\n   * @param entryId\n   * @returns {Promise<*>}\n   */\n  resume(entryId): Promise<*> {\n    OfflineManager._logger.debug('resume started', entryId);\n    return this._offlineProvider.setSessionData(entryId).then(() => {\n      let currentDownload = this._downloads[entryId];\n      this._recoverEntry(entryId);\n      if (currentDownload.state === downloadStates.PAUSED) {\n        currentDownload.state = downloadStates.RESUMED;\n        return this._offlineProvider.resume(entryId).then((manifestDB) => {\n          currentDownload.state = [manifestDB.downloadStatus, manifestDB.ob].includes(downloadStates.ENDED) ? downloadStates.ENDED : downloadStates.PAUSED;\n          this._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, this._offlineProvider.prepareItemForStorage(currentDownload)).then(() => {\n            OfflineManager._logger.debug('resume ended / paused', entryId);\n            return Promise.resolve({\n              state: currentDownload.state,\n              entryId: entryId\n            });\n          })\n        });\n      }\n    }).catch((error) => {\n      this._onError(error);\n    });\n  }\n\n  /**\n   * This function gets an entryId and renew it's DRM license from the server\n   * @param entryId\n   * @returns {Promise<T>}\n   */\n  renewLicense(entryId): Promise<*> {\n    OfflineManager._logger.debug('renew license started', entryId);\n    const provider = new Provider(this._config.provider);\n    return provider.getMediaConfig({\n      entryId: entryId\n    }).then(mediaConfig => {\n      if (!Utils.Object.hasPropertyPath(mediaConfig, 'sources.dash') && mediaConfig.sources.dash.length > 0) {\n        this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.RENEW_LICENSE_FAILED, 'not enough data from the media provider'));\n      }\n      return this._offlineProvider.setSessionData(entryId, mediaConfig).then(() => {\n        let currentDownload = this._downloads[entryId];\n        if (currentDownload.state === downloadStates.ENDED) {\n          this._offlineProvider.renewLicense(entryId).then((expiration) => {\n            this._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, this._offlineProvider.prepareItemForStorage(currentDownload)).then(() => {\n              OfflineManager._logger.debug('renew license ended', entryId);\n              return Promise.resolve({\n                state: currentDownload.state,\n                entryId: entryId,\n                expiration: expiration\n              });\n            })\n          });\n        }\n      })\n    }).catch((error) => {\n      this._onError(error);\n    });\n  }\n\n  download(entryId: string, options: Object): Promise<*> {\n    return new Promise((resolve) => {\n      OfflineManager._logger.debug('download start', entryId);\n      let currentDownload = this._downloads[entryId];\n      if (currentDownload.state) {\n        this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.ENTRY_ALREADY_EXISTS, entryId));\n        return;\n      }\n      this._doesEntryExists(entryId).then(existsInDB => {\n        if (existsInDB) {\n          this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.ENTRY_ALREADY_EXISTS, entryId));\n          return;\n        }\n        currentDownload['state'] = downloadStates.DOWNLOADING;\n        this._addDownloadParam(entryId);\n        this._offlineProvider.download(entryId, options)\n          .then(this._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, this._offlineProvider.prepareItemForStorage(currentDownload)))\n          .then(() => {\n            OfflineManager._logger.debug('download ended / paused', entryId);\n            resolve({\n              state: currentDownload.state,\n              entryId: entryId\n            });\n          }).catch(error => this._onError(error));\n      });\n    });\n  }\n\n  remove(entryId: string): Promise<*> {\n    OfflineManager._logger.debug('remove start', entryId);\n    return this._offlineProvider.setSessionData(entryId).then(() => {\n      let currentDownload = this._downloads[entryId];\n      if (!currentDownload.state) {\n        this._onError(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.REQUESTED_ITEM_NOT_FOUND));\n      }\n      this._offlineProvider.remove(entryId).then(() => {\n        this._dbManager.remove(ENTRIES_MAP_STORE_NAME, entryId).then(() => {\n          delete this._downloads[entryId];\n          OfflineManager._logger.debug('remove ended', entryId);\n          return Promise.resolve({\n            state: currentDownload.state,\n            entryId: entryId\n          });\n        })\n      })\n    }).catch(error => this._onError(error));\n  }\n\n\n  removeAll(): Promise<*> {\n    let promises = [];\n    return this.getAllDownloads().then(downloads => {\n      downloads.forEach(download => {\n        promises.push(this.remove(download.sources.id));\n      });\n      this._downloads = {};\n      return Promise.all(promises);\n    });\n  }\n\n  pauseAll(): Promise<*> {\n    let promises = [];\n    return this.getAllDownloads().then(downloads => {\n      downloads.forEach(download => {\n        promises.push(this.pause(download.sources.id));\n      });\n      return Promise.all(promises);\n    });\n  }\n\n  getExpiration(entryId): Promise<*> {\n    return this.getDownloadedMediaConfig(entryId).then(data => {\n      return data.expiration;\n    });\n  }\n\n  /**\n   * Getting the full media config of an entry from the indexed db. It contains the full provider info\n   * the status of the download, actual size of the entry, expected size (full size) and drm expiration date.\n   * @param entryId\n   * @returns {*}\n   */\n  getDownloadedMediaConfig(entryId: string): Promise<*> {\n    OfflineManager._logger.debug('getDownloadedMediaConfig', entryId);\n    return this._dbManager.get(ENTRIES_MAP_STORE_NAME, entryId);\n  }\n\n  /**\n   * Getting all the in progress, ended, resumed, paused and ended downloads.\n   * @returns {Promise<Array<Object>>}\n   */\n  getAllDownloads(): Promise<*> {\n    if (this._isDBSynced) {\n      return Promise.resolve(this._getReducedDownloadObjectsData());\n    }\n    return this._dbManager.getAll(ENTRIES_MAP_STORE_NAME).then(dbDownloads => {\n      this._isDBSynced = true;\n      dbDownloads.forEach((download) => {\n        const entryId = download.sources.id;\n        if (!this._downloads[entryId]) {\n          this._downloads[entryId] = download;\n          this._recoverEntry(entryId);\n        }\n      });\n      return Promise.resolve(this._getReducedDownloadObjectsData());\n    });\n  }\n\n  /**\n   * add parameter to the manifest url so the server will know it's only for downloading and not playing (stats purpose)\n   * @param entryId\n   * @private\n   */\n  _addDownloadParam(entryId: string): void {\n    let currentDownload = this._downloads[entryId];\n    currentDownload.sources.dash[0].url = currentDownload.sources.dash[0].url + DOWNLOAD_PARAM;\n  }\n\n  /**\n   * checking if an entry exists already in the DB.\n   * @param entryId\n   * @returns {Promise<any>}\n   * @private\n   */\n  _doesEntryExists(entryId): Promise<*> {\n    return new Promise((resolve) => {\n      return this.getDownloadedMediaConfig(entryId).then((entry) => {\n        resolve(entry && entry.state);\n      })\n    })\n  }\n\n  /**\n   * Removing  sources that we are not downloading from the media config\n   * currently as we are having only dash adapter, we will take the first dash source.\n   * @param {Object} mediaConfig\n   * @private\n   */\n  _removeNotRelevantSources(mediaConfig: Object): Object {\n    for (let key in mediaConfig.sources) {\n      let source = mediaConfig.sources[key];\n      if (NOT_SUPPORTED_SOURCE_TYPES.includes(key)) {\n        delete mediaConfig.sources[key];\n      } else if (key === SUPPORTED_SOURCE) {\n        source = source.slice(1);\n      }\n    }\n    return Object.assign({}, mediaConfig);\n  }\n\n  /**\n   * The indexed db can contain corrupted values regarding a download if something goes wrong.\n   * for example, it can has a \"downloading\" state while there is nothing downloaded,\n   * if a download was interrupted unexpectedly (browser crash e.g).\n   * this function handles this.\n   * @private\n   */\n  _recoverEntry(entryId) {\n    let currEntry = this._downloads[entryId];\n    if (!currEntry || currEntry.recovered) {\n      return;\n    } else {\n      if (currEntry.state === downloadStates.DOWNLOADING || currEntry.state === downloadStates.RESUMED) {\n        currEntry.state = downloadStates.PAUSED;\n      }\n      currEntry.recovered = true;\n    }\n  }\n\n  /**\n   * get a reduced and normalized version of the provider data.\n   * @returns {Array<Object>}\n   * @private\n   */\n  _getReducedDownloadObjectsData() {\n    return Object.keys(this._downloads).map(i => {\n      const item = this._downloads[i];\n      return {\n        id: item.sources.id,\n        metadata: item.sources.metadata,\n        poster: item.sources.poster,\n        expectedSize: item.expectedSize,\n        size: item.size,\n        expiration: item.expiration,\n        duration: item.sources.duration,\n        state: item.state\n      };\n    });\n  }\n\n  /**\n   * Error handler, dispatches an error object\n   * @param error\n   * @private\n   */\n  _onError(error: Error): void {\n    let event = new FakeEvent(EVENTS.ERROR, error);\n    this.dispatchEvent(event);\n  }\n\n  /**\n   * TODO: Define the destroy logic of your plugin.\n   * Destroys the plugin.\n   * @override\n   * @public\n   * @returns {void}\n   */\n  destroy(): void {\n    // Write logic\n    this._eventManager.destroy();\n  }\n\n  /**\n   * TODO: Define the reset logic of your plugin.\n   * Resets the plugin.\n   * @override\n   * @public\n   * @returns {void}\n   */\n  reset(): void {\n    // Write logic\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./offline-manager.js","//flow\nimport shaka from 'shaka-player'\nimport DBManager from './db-manager';\nimport {FakeEventTarget, FakeEvent, Error, EventType as EVENTS} from 'playkit-js'\nimport getLogger from './utils/logger'\n\nconst downloadStates = {\n  DOWNLOADING: 'downloading',\n  PAUSED: 'paused',\n  RESUMED: 'resumed',\n  ENDED: 'ended'\n};\n\nconst ENTRIES_MAP_STORE_NAME = 'entriesMap';\n\nexport const PROGRESS_EVENT = 'progress';\n\nexport class ShakaOfflineProvider extends FakeEventTarget {\n\n  static _logger: any = getLogger('ShakaOfflineProvider');\n\n  constructor(downloads) {\n    super();\n    ShakaOfflineProvider._logger.debug('ShakaOfflineProvider created');\n    this._dtgVideoElement = document.createElement('video');\n    shaka.polyfill.installAll();\n    this._dtgShaka = new shaka.Player(this._dtgVideoElement);\n    this._configureShakaPlayer();\n    this._dtgShaka.addEventListener(EVENTS.ERROR, this._onShakaError);\n    // todo remove this as part of the classes refactor, adding the offline provider config should be on \"item.prepareforstorage()\"\n    this._dbManager = new DBManager({\n      adapterName: 'shaka',\n      adapterVersion: \"\",//player.version,\n      playerVersion: \"\"//player.version\n    });\n    this._downloads = downloads;\n  }\n\n  _configureShakaPlayer(): void {\n    this._dtgShaka.configure({\n      streaming: {\n        retryParameters: {\n          timeout: 0,       // timeout in ms, after which we abort a request; 0 means never\n          maxAttempts: 100,   // the maximum number of requests before we fail\n          baseDelay: 1000,  // the base delay in ms between retries\n          backoffFactor: 2, // the multiplicative backoff factor between retries\n          fuzzFactor: 0.5  // the fuzz factor to apply to each retry delay\n        }\n      }\n    });\n  }\n\n  download(entryId: String, options): Promise<*> {\n    return new Promise((resolve, reject) => {\n      ShakaOfflineProvider._logger.debug('download', entryId);\n      let currentDownload = this._downloads[entryId];\n      this._configureDrmIfNeeded(entryId);\n      currentDownload['storage'] = this._initStorage(entryId, options);\n      // first store manifest\n      return currentDownload.storage.storeManifest(currentDownload.sources.dash[0].url, {}).then(manifest => {\n        ShakaOfflineProvider._logger.debug('after storage.storeManifest', entryId);\n        currentDownload.state = downloadStates.DOWNLOADING;\n        currentDownload.recovered = true;\n        currentDownload.sources.dash[0].url = manifest.offlineUri;\n        currentDownload.expiration = manifest.expiration;\n        currentDownload.expectedSize = manifest.expectedSize;\n        currentDownload.size = 0;\n        return this._dbManager.add(ENTRIES_MAP_STORE_NAME, entryId, this.prepareItemForStorage(currentDownload)).then(() => {\n          return currentDownload.storage.download(currentDownload.sources.dash[0].url).then(manifest => {\n            currentDownload.size = manifest.size;\n            currentDownload.state = manifest.downloadStatus;\n            resolve();\n          })\n        })\n      }).catch(error => {\n        // Shaka error's data parameter is an array, we want to normalize it.\n        const data = Array.isArray(error.data) ? error.data[0] : error.data;\n        return reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.DOWNLOAD_FAILED, data));\n      });\n    })\n  }\n\n  pause(entryId: string): Promise<*> {\n    ShakaOfflineProvider._logger.debug('pause', entryId);\n    const currentDownload = this._downloads[entryId];\n    return currentDownload.storage.pause().catch(error => {\n      return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.PAUSE_FAILED, error.data && error.data[0]));\n    });\n  }\n\n  resume(entryId: string): Promise<*> {\n    ShakaOfflineProvider._logger.debug('resume', entryId);\n    const currentDownload = this._downloads[entryId];\n    return currentDownload.storage.download(currentDownload.sources.dash[0].url)\n      .catch(error => {\n        return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.RESUME_FAILED, error.data && error.data[0]));\n      });\n  }\n\n  remove(entryId): Promise<*> {\n    ShakaOfflineProvider._logger.debug('remove', entryId);\n    const currentDownload = this._downloads[entryId];\n    // in case of removing a download in progress, we have to pause the download and wait for the\n    // store promise to be resolved. Only then we will have the shaka offline storage uri, so it can be deleted\n    // from the shaka indexed db as well.\n    let pausePromise = currentDownload.state === downloadStates.ENDED ? Promise.resolve() : this.pause(entryId);\n    let storePormise = currentDownload.storePromise || Promise.resolve();\n    return Promise.all([pausePromise, storePormise]).then(() => {\n      currentDownload.storage = this._initStorage(entryId, {action: 'remove'});\n      return currentDownload.storage.remove(currentDownload.sources.dash[0].url);\n    }).catch(error => {\n      return Promise.reject(new Error(Error.Severity.RECOVERABLE, Error.Category.STORAGE, Error.Code.REMOVE_FAILED, error.data && error.data[0]));\n    });\n  }\n\n  renewLicense(entryId): Promise<*> {\n    ShakaOfflineProvider._logger.debug('renewLicense', entryId);\n    const currentDownload = this._downloads[entryId];\n    this._configureDrmIfNeeded(entryId);\n    currentDownload['storage'] = this._initStorage(entryId, {});\n    return currentDownload.storage.renewLicense(currentDownload.sources.dash[0].url).then(manifestDB => {\n      currentDownload.expiration = manifestDB.expiration;\n      return Promise.resolve(manifestDB.expiration);\n    });\n  }\n\n  getDataByEntry(entryId): Promise<*> {\n    return this._dbManager.get(ENTRIES_MAP_STORE_NAME, entryId);\n  }\n\n  getAllDownloads(): Promise<*> {\n    return this._dbManager.getAll(ENTRIES_MAP_STORE_NAME);\n  }\n\n  _onShakaError(event: any): void {\n    if (event && event.detail) {\n      const error = event.detail;\n      //currently we don't handle video element errors on the offline shaka\n      if (error.code === this.VIDEO_ERROR_CODE) {\n        ShakaOfflineProvider._logger.error(error);\n        return;\n      }\n      const playerError = new Error(\n        error.severity,\n        error.category,\n        error.code,\n        error.data);\n      ShakaOfflineProvider._logger.error(playerError);\n      this.dispatchEvent(new FakeEvent(EVENTS.ERROR, playerError));\n    }\n  }\n\n  _configureDrmIfNeeded(entryId) {\n    ShakaOfflineProvider._logger.debug('configure drm if needed', entryId);\n    let currentDownload = this._downloads[entryId];\n    const drmData = currentDownload.sources.dash[0].drmData;\n    if (drmData) {\n      let servers = {};\n      drmData.forEach((val) => {\n        servers[val.scheme] = val.licenseUrl;\n      });\n      this._dtgShaka.configure({'drm': {'servers': servers}})\n    } else {\n      this._dtgShaka.configure({});\n    }\n  }\n\n  prepareItemForStorage(object) {\n    const keysToDelete = [\"storage\", \"url\", \"mimetype\", \"storePromise\", \"recovered\"];\n    let storeObj = Object.assign({}, object);\n    for (let key in storeObj) {\n      if (keysToDelete.includes(key)) {\n        delete storeObj[key];\n      }\n    }\n    let selectedSource = object.sources.dash[0];\n    selectedSource['localSource'] = true;\n    object.sources.dash = [selectedSource]; // storing only one relevant source\n    return storeObj;\n  }\n\n  /**\n   * This function makes an entry ready to be used by the download manager.\n   * It gets the entry data from DB, it refreshes the drm data and create a shaka storage\n   * object if one was not created already.\n   * @param entryId\n   * @param newMediaInfo - new mediaInfo from the server (used for renewDRM) TODO: pass only drm data?\n   * @returns {Promise<any>}\n   */\n  setSessionData(entryId, newMediaInfo): Promise<*> {\n    ShakaOfflineProvider._logger.debug('set session data', entryId);\n    return new Promise((resolve, reject) => {\n      if (this._downloads[entryId]) {\n        return resolve();\n      }\n      return this.getDataByEntry(entryId).then(dbData => {\n        let data = Object.assign({}, dbData);\n        this._downloads[entryId] = data;\n        return resolve();\n      }).catch(error => {\n        return reject(error);\n      });\n    }).then(() => {\n      let currentDownload = this._downloads[entryId];\n      currentDownload.storage = currentDownload.storage ? currentDownload.storage : this._initStorage(entryId);\n      this._updateDrmDataIfNeeded(entryId, newMediaInfo);\n      return Promise.resolve();\n    }).catch(error => {\n      return Promise.reject(error);\n    });\n  }\n\n  _updateDrmDataIfNeeded(entryId, newMediaInfo) {\n    if (!newMediaInfo) {\n      return;\n    }\n    let currentDownload_ = this._downloads[entryId];\n    if (currentDownload_.sources.dash[0].drmData && newMediaInfo.sources.dash[0].drmData) {\n      currentDownload_.sources.dash[0].drmData = newMediaInfo.sources.dash[0].drmData;\n    }\n  }\n\n  _trackSelectionCallback(bitrate = 0, language = null) {\n    return function (tracks) {\n      const textTracks = tracks.filter(track => {\n        return track.type === 'text'\n      });\n      const langFilteredTracks = tracks.filter(track => {\n        return track.language === language && track.type !== 'text'\n      });\n      tracks = langFilteredTracks.length > 0 ? langFilteredTracks : tracks;\n      let closest = tracks.reduce(function (prev, curr) {\n        return (Math.abs(curr.bandwidth - bitrate) < Math.abs(prev.bandwidth - bitrate) ? curr : prev);\n      });\n      return [closest].concat(textTracks);\n    }\n  }\n\n  _initStorage(entryId, options = {}) {\n    ShakaOfflineProvider._logger.debug('init storage', entryId);\n    let storage = new shaka.offline.Storage(this._dtgShaka);\n    let configuration = {\n      usePersistentLicense: true\n    };\n    if (options.bitrate || options.language) {\n      configuration[\"trackSelectionCallback\"] = this._trackSelectionCallback(options.bitrate, options.language);\n    }\n    if (!options.action || options.action !== 'remove') {\n      configuration[\"progressCallback\"] = this._setDownloadProgress(entryId);\n    }\n    storage.configure(configuration);\n    return storage;\n  }\n\n  _setDownloadProgress(entryId) {\n    ShakaOfflineProvider._logger.debug('set download progress', entryId);\n    return (content, progress) => {\n      let currentDownload_ = this._downloads[entryId];\n      currentDownload_.size = content.size;\n      this._dbManager.update(ENTRIES_MAP_STORE_NAME, entryId, this.prepareItemForStorage(currentDownload_));\n      let event = new FakeEvent(PROGRESS_EVENT, {\n        detail: {\n          content: content,\n          progress: progress * 100,\n          entryId: entryId\n        },\n        details: {\n          content: content,\n          progress: progress * 100,\n          entryId: entryId\n        }\n      });\n      this.dispatchEvent(event);\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./shaka-offline-provider.js","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"shaka-player\",\"commonjs2\":\"shaka-player\",\"amd\":\"shaka-player\",\"root\":[\"KalturaPlayer\",\"shaka\"]}\n// module id = 6\n// module chunks = 0","'use strict';\n\n(function() {\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function(resolve, reject) {\n      request.onsuccess = function() {\n        resolve(request.result);\n      };\n\n      request.onerror = function() {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function(resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function(value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function(prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function() {\n          return this[targetProp][prop];\n        },\n        set: function(val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function(prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function() {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function(methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function() {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function() {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function(value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function() {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function() {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function(resolve, reject) {\n      idbTransaction.oncomplete = function() {\n        resolve();\n      };\n      idbTransaction.onerror = function() {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function() {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function() {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function() {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function() {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function(funcName) {\n    [ObjectStore, Index].forEach(function(Constructor) {\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function() {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function() {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function(Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function(query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function(resolve) {\n        instance.iterateCursor(query, function(cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  var exp = {\n    open: function(name, version, upgradeCallback) {\n      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n      var request = p.request;\n\n      request.onupgradeneeded = function(event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n\n      return p.then(function(db) {\n        return new DB(db);\n      });\n    },\n    delete: function(name) {\n      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n    }\n  };\n\n  if (typeof module !== 'undefined') {\n    module.exports = exp;\n    module.exports.default = module.exports;\n  }\n  else {\n    self.idb = exp;\n  }\n}());\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/idb/lib/idb.js\n// module id = 7\n// module chunks = 0","/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\r\n(function (global) {\r\n\t\"use strict\";\r\n\r\n\t// Top level module for the global, static logger instance.\r\n\tvar Logger = { };\r\n\r\n\t// For those that are at home that are keeping score.\r\n\tLogger.VERSION = \"1.4.1\";\r\n\r\n\t// Function which handles all incoming log messages.\r\n\tvar logHandler;\r\n\r\n\t// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\r\n\tvar contextualLoggersByNameMap = {};\r\n\r\n\t// Polyfill for ES5's Function.bind.\r\n\tvar bind = function(scope, func) {\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t// Super exciting object merger-matron 9000 adding another 100 bytes to your download.\r\n\tvar merge = function () {\r\n\t\tvar args = arguments, target = args[0], key, i;\r\n\t\tfor (i = 1; i < args.length; i++) {\r\n\t\t\tfor (key in args[i]) {\r\n\t\t\t\tif (!(key in target) && args[i].hasOwnProperty(key)) {\r\n\t\t\t\t\ttarget[key] = args[i][key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\t// Helper to define a logging level object; helps with optimisation.\r\n\tvar defineLogLevel = function(value, name) {\r\n\t\treturn { value: value, name: name };\r\n\t};\r\n\r\n\t// Predefined logging levels.\r\n\tLogger.DEBUG = defineLogLevel(1, 'DEBUG');\r\n\tLogger.INFO = defineLogLevel(2, 'INFO');\r\n\tLogger.TIME = defineLogLevel(3, 'TIME');\r\n\tLogger.WARN = defineLogLevel(4, 'WARN');\r\n\tLogger.ERROR = defineLogLevel(8, 'ERROR');\r\n\tLogger.OFF = defineLogLevel(99, 'OFF');\r\n\r\n\t// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\r\n\t// of each other.\r\n\tvar ContextualLogger = function(defaultContext) {\r\n\t\tthis.context = defaultContext;\r\n\t\tthis.setLevel(defaultContext.filterLevel);\r\n\t\tthis.log = this.info;  // Convenience alias.\r\n\t};\r\n\r\n\tContextualLogger.prototype = {\r\n\t\t// Changes the current logging level for the logging instance.\r\n\t\tsetLevel: function (newLevel) {\r\n\t\t\t// Ensure the supplied Level object looks valid.\r\n\t\t\tif (newLevel && \"value\" in newLevel) {\r\n\t\t\t\tthis.context.filterLevel = newLevel;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// Gets the current logging level for the logging instance\r\n\t\tgetLevel: function () {\r\n\t\t\treturn this.context.filterLevel;\r\n\t\t},\r\n\r\n\t\t// Is the logger configured to output messages at the supplied level?\r\n\t\tenabledFor: function (lvl) {\r\n\t\t\tvar filterLevel = this.context.filterLevel;\r\n\t\t\treturn lvl.value >= filterLevel.value;\r\n\t\t},\r\n\r\n\t\tdebug: function () {\r\n\t\t\tthis.invoke(Logger.DEBUG, arguments);\r\n\t\t},\r\n\r\n\t\tinfo: function () {\r\n\t\t\tthis.invoke(Logger.INFO, arguments);\r\n\t\t},\r\n\r\n\t\twarn: function () {\r\n\t\t\tthis.invoke(Logger.WARN, arguments);\r\n\t\t},\r\n\r\n\t\terror: function () {\r\n\t\t\tthis.invoke(Logger.ERROR, arguments);\r\n\t\t},\r\n\r\n\t\ttime: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'start' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttimeEnd: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'end' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Invokes the logger callback if it's not being filtered.\r\n\t\tinvoke: function (level, msgArgs) {\r\n\t\t\tif (logHandler && this.enabledFor(level)) {\r\n\t\t\t\tlogHandler(msgArgs, merge({ level: level }, this.context));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Protected instance which all calls to the to level `Logger` module will be routed through.\r\n\tvar globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });\r\n\r\n\t// Configure the global Logger instance.\r\n\t(function() {\r\n\t\t// Shortcut for optimisers.\r\n\t\tvar L = Logger;\r\n\r\n\t\tL.enabledFor = bind(globalLogger, globalLogger.enabledFor);\r\n\t\tL.debug = bind(globalLogger, globalLogger.debug);\r\n\t\tL.time = bind(globalLogger, globalLogger.time);\r\n\t\tL.timeEnd = bind(globalLogger, globalLogger.timeEnd);\r\n\t\tL.info = bind(globalLogger, globalLogger.info);\r\n\t\tL.warn = bind(globalLogger, globalLogger.warn);\r\n\t\tL.error = bind(globalLogger, globalLogger.error);\r\n\r\n\t\t// Don't forget the convenience alias!\r\n\t\tL.log = L.info;\r\n\t}());\r\n\r\n\t// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\r\n\t// object with the supplied log messages and the second being a context object which contains a hash of stateful\r\n\t// parameters which the logging function can consume.\r\n\tLogger.setHandler = function (func) {\r\n\t\tlogHandler = func;\r\n\t};\r\n\r\n\t// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\r\n\t// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\r\n\tLogger.setLevel = function(level) {\r\n\t\t// Set the globalLogger's level.\r\n\t\tglobalLogger.setLevel(level);\r\n\r\n\t\t// Apply this level to all registered contextual loggers.\r\n\t\tfor (var key in contextualLoggersByNameMap) {\r\n\t\t\tif (contextualLoggersByNameMap.hasOwnProperty(key)) {\r\n\t\t\t\tcontextualLoggersByNameMap[key].setLevel(level);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Gets the global logging filter level\r\n\tLogger.getLevel = function() {\r\n\t\treturn globalLogger.getLevel();\r\n\t};\r\n\r\n\t// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\r\n\t// default context and log handler.\r\n\tLogger.get = function (name) {\r\n\t\t// All logger instances are cached so they can be configured ahead of use.\r\n\t\treturn contextualLoggersByNameMap[name] ||\r\n\t\t\t(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));\r\n\t};\r\n\r\n\t// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\r\n\t// write to the window's console object (if present); the optional options object can be used to customise the\r\n\t// formatter used to format each log message.\r\n\tLogger.createDefaultHandler = function (options) {\r\n\t\toptions = options || {};\r\n\r\n\t\toptions.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\r\n\t\t\t// Prepend the logger's name to the log message for easy identification.\r\n\t\t\tif (context.name) {\r\n\t\t\t\tmessages.unshift(\"[\" + context.name + \"]\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\r\n\t\t// that don't offer a native console method.\r\n\t\tvar timerStartTimeByLabelMap = {};\r\n\r\n\t\t// Support for IE8+ (and other, slightly more sane environments)\r\n\t\tvar invokeConsoleMethod = function (hdlr, messages) {\r\n\t\t\tFunction.prototype.apply.call(hdlr, console, messages);\r\n\t\t};\r\n\r\n\t\t// Check for the presence of a logger.\r\n\t\tif (typeof console === \"undefined\") {\r\n\t\t\treturn function () { /* no console */ };\r\n\t\t}\r\n\r\n\t\treturn function(messages, context) {\r\n\t\t\t// Convert arguments object to Array.\r\n\t\t\tmessages = Array.prototype.slice.call(messages);\r\n\r\n\t\t\tvar hdlr = console.log;\r\n\t\t\tvar timerLabel;\r\n\r\n\t\t\tif (context.level === Logger.TIME) {\r\n\t\t\t\ttimerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\r\n\r\n\t\t\t\tif (messages[1] === 'start') {\r\n\t\t\t\t\tif (console.time) {\r\n\t\t\t\t\t\tconsole.time(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttimerStartTimeByLabelMap[timerLabel] = new Date().getTime();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (console.timeEnd) {\r\n\t\t\t\t\t\tconsole.timeEnd(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinvokeConsoleMethod(hdlr, [ timerLabel + ': ' +\r\n\t\t\t\t\t\t\t(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Delegate through to custom warn/error loggers if present on the console.\r\n\t\t\t\tif (context.level === Logger.WARN && console.warn) {\r\n\t\t\t\t\thdlr = console.warn;\r\n\t\t\t\t} else if (context.level === Logger.ERROR && console.error) {\r\n\t\t\t\t\thdlr = console.error;\r\n\t\t\t\t} else if (context.level === Logger.INFO && console.info) {\r\n\t\t\t\t\thdlr = console.info;\r\n\t\t\t\t} else if (context.level === Logger.DEBUG && console.debug) {\r\n\t\t\t\t\thdlr = console.debug;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toptions.formatter(messages, context);\r\n\t\t\t\tinvokeConsoleMethod(hdlr, messages);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t// Configure and example a Default implementation which writes to the `window.console` (if present).  The\r\n\t// `options` hash can be used to configure the default logLevel and provide a custom message formatter.\r\n\tLogger.useDefaults = function(options) {\r\n\t\tLogger.setLevel(options && options.defaultLevel || Logger.DEBUG);\r\n\t\tLogger.setHandler(Logger.createDefaultHandler(options));\r\n\t};\r\n\r\n\t// Export to popular environments boilerplate.\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine(Logger);\r\n\t}\r\n\telse if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = Logger;\r\n\t}\r\n\telse {\r\n\t\tLogger._prevLogger = global.Logger;\r\n\r\n\t\tLogger.noConflict = function () {\r\n\t\t\tglobal.Logger = Logger._prevLogger;\r\n\t\t\treturn Logger;\r\n\t\t};\r\n\r\n\t\tglobal.Logger = Logger;\r\n\t}\r\n}(this));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/js-logger/src/logger.js\n// module id = 8\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"playkit-js-providers\",\"commonjs2\":\"playkit-js-providers\",\"amd\":\"playkit-js-providers\",\"root\":[\"KalturaPlayer\",\"providers\"]}\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}